This file is the short summary of the API changes:

29.02.2016 - Non-backward compatible
    Several types and instructions are renamed to improve
    readability. In general byte, half, and int are renamed
    to 8, 16, and 32. Floating point types are also renamed
    from d and s to f64 and f32.

      [s|u]b -> [s|u]8    (8 bit values)
      [s|u]h -> [s|u]16   (16 bit values)
      [s|u]i -> [s|u]32   (32 bit values)
      d -> f64            (64 bit floating point value)
      s -> f32            (32 bit floating point value)

18.05.2015 - Non-backward compatible
    SLJIT_[I|]L[U|S]DIV is renamed to SLJIT_[I|][U|S]DIVMOD

29.09.2014 - Non-backward compatible
    The sljit_create_compiler, sljit_allocate_stack, and
    sljit_free_stack functions have an allocator_data
    argument now.

19.09.2014 - Non-backward compatible
    Using I, D, S prefixes in conditional and floating
    point operations. And an L prefix to long multiplication
    and division (op0 opcodes).

11.08.2014 - Non-backward compatible
    A currently unused options parameter is added to sljit_emit_enter
    and sljit_set_context.

06.07.2014 - Non-backward compatible
    SCRATCH registers are renamed to Rx and SAVED registers
    are renamed to Sx. See the explanation of these registers
    in sljitLir.h.

31.05.2014 - Non-backward compatible
    SLJIT_TEMPORARY_EREGx registers were not renamed to
    SLJIT_SCRATCH_EREGx when the change was done on 08.11.2012

05.03.2014 - Backward compatible
    The sljit_set_target now supports those jumps, which
    does not created with SLJIT_REWRITABLE_JUMP flag.
    Reason: sljit_emit_ijump does not support conditional
    jumps.

03.03.2014 - Non-backward compatible
    SLJIT_MOV_UI cannot be combined with SLJIT_INT_OP.
    Reason: SLJIT_INT_OP flag is not recommended to use
    directly, and SLJIT_IMOV has no sign bit.

29.01.2014 - Backward compatible
    Bits assigned to SLJIT_MEM and SLJIT_IMM flags are changed.
    Reason: the most common cases are fits into one byte now,
    and more registers can be supported in the future.

08.11.2012 - Non-backward compatible
    SLJIT_TEMPORARY_REGx registers are renamed to SLJIT_SCRATCH_REGx.

07.11.2012 - Non-backward compatible
    sljit_emit_cond_value is renamed to sljit_emit_op_flags. An
    extra source argument is added which will be used in the future.

05.11.2012 - Backward compatible
    sljit_emit_cond_value now supports SLJIT_AND and SLJIT_INT_OP
    flags, which makes this function complete.

01.11.2012 - Non-backward compatible
    SLJIT_F* opcodes are renamed to SLJIT_*D to show that
    they are double precision operators. Furthermore
    SLJIT_*S single precision opcodes are added.

01.11.2012 - Non-backward compatible
    Register arguments of operations with SLJIT_INT_OP flag
    must be computed by another operation with SLJIT_INT_OP flag.
    The same way as SLJIT_SINGLE_OP flag works with floating point
    numbers. See the description of SLJIT_INT_OP.

01.11.2012 - Backward compatible
    All operations whose support the SLJIT_INT_OP flag, have an
    alternate name now, which includes the SLJIT_INT_OP. These
    names starting with I.

31.10.2012 - Non-backward compatible
    Renaming sljit_w to sljit_sw, sljit_i to sljit_si, sljit_h
    to sljit_sh, and sljit_b to sljit_sb. Reason: their sign
    bit is part of the type now.

20.10.2012 - Non-backward compatible
    Renaming SLJIT_C_FLOAT_NAN to SLJIT_C_FLOAT_UNORDERED.
    Reason: all architectures call these unordered comparions.
